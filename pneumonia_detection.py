# -*- coding: utf-8 -*-
"""Pneumonia Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OGQe5uwWQtZBiqop0NN5nZpfAiYRZOSo
"""

from google.colab import drive
drive.mount('/content/gdrive')

"""# VGG16"""

img_width  = 224
img_height = 224

from keras.applications import VGG16

conv_base = VGG16(weights= 'imagenet',
                 include_top= False,
                 input_shape=(img_width, img_height, 3))

from keras import models
from keras import layers

model = models.Sequential() 
model.add(conv_base)
model.add(layers.Flatten()) 
model.add(layers.Dense(256, activation='relu')) 
model.add(layers.Dense(1, activation='sigmoid'))

print("\nStructure of our model -- ")
model.summary()

conv_base.trainable = False

import os
from keras.preprocessing.image import ImageDataGenerator


base_dir = r'/content/gdrive/My Drive/chest_xray'
train_dir = os.path.join(base_dir, 'train')
validation_dir = os.path.join(base_dir, 'val')
test_dir = os.path.join(base_dir, 'test')

train_sample_size = 5216
train_batch_size = 32

valid_sample_size = 16
valid_batch_size = 8

test_sample_size = 624
test_batch_size = 32

from keras.preprocessing.image import ImageDataGenerator
train_datagen = ImageDataGenerator( 
                  rescale=1./255,
                  rotation_range=300, 
                  width_shift_range=0.1, 
                  height_shift_range=0.1, 
                  shear_range=0.2, 
                  zoom_range=0.2, 
                  horizontal_flip=True, 
                  fill_mode='nearest')

test_datagen = ImageDataGenerator(rescale=1./255)

from keras.preprocessing import image
import matplotlib.pyplot as plt

# An image chosen from the dataset
img_path = '/content/gdrive/My Drive/chest_xray/train/PNEUMONIA/person1008_bacteria_2939.jpeg'

# Reads the image and resizes it
img = image.load_img(img_path, target_size=(150, 150))

# Converts to Numpy array with shape (150, 150, 3)
x = image.img_to_array(img)

# Reshapes into (1, 150, 150, 3)
x = x.reshape((1,) + x.shape)

i = 0
for batch in train_datagen.flow(x, batch_size=1):
  plt.figure(i)
  imgplot = plt.imshow(image.array_to_img(batch[0]))
  i += 1
  if i%10 == 0:
    break

plt.show()

train_generator = train_datagen.flow_from_directory(
        train_dir,
        target_size=(img_width, img_height),
        batch_size= train_batch_size,
        class_mode='binary')

validation_generator = test_datagen.flow_from_directory(
        validation_dir,
        target_size=(img_width, img_height),
        batch_size= valid_batch_size,
        class_mode='binary')

from keras import optimizers
model.compile(loss='binary_crossentropy', optimizer='adam',
              metrics=['acc'])

STEP_SIZE_TRAIN = train_generator.n//train_generator.batch_size
STEP_SIZE_VALID = validation_generator.n//validation_generator.batch_size

history = model.fit_generator( 
      train_generator,
      steps_per_epoch=STEP_SIZE_TRAIN,
      epochs=7,
      validation_data=validation_generator,
      validation_steps=STEP_SIZE_VALID)

# Plotting the results
import matplotlib.pyplot as plt


def plot_result(history, model):
  acc = history.history['acc'] 
  val_acc = history.history['val_acc'] 
  loss = history.history['loss'] 
  val_loss = history.history['val_loss']

  epochs = range(1, len(acc) + 1)

  plt.plot(epochs, acc, 'bo', label='Training acc') 
  plt.plot(epochs, val_acc, 'b', label='Validation acc') 
  plt.title('Training and validation accuracy of ' + model) 
  plt.legend()

  plt.figure()

  plt.plot(epochs, loss, 'bo', label='Training loss')
  plt.plot(epochs, val_loss, 'b', label='Validation loss') 
  plt.title('Training and validation loss of ' + model) 
  plt.legend()

  plt.show()

plot_result(history, "VGG16")

acc = history.history['acc'] 
val_acc = history.history['val_acc'] 
train_accVGG16 = acc[-1]
val_accVGG16   = val_acc[-1]
print(train_accVGG16)
print(val_accVGG16)

test_batch_size = 1
test_generator = test_datagen.flow_from_directory(
                                directory= test_dir, 
                                target_size= (img_width, img_height), 
                                batch_size= test_batch_size,
                                class_mode= 'binary', 
                                shuffle= False)

print(test_generator.class_indices)

STEP_SIZE_TEST = test_generator.n//(test_generator.batch_size)
print(STEP_SIZE_TEST)
print(test_generator.n)
print(test_generator.batch_size)

from sklearn.metrics import classification_report, confusion_matrix
import numpy as np

#Confusion Matrix and Classification Report
Y_pred = model.predict_generator(test_generator, 624)

y_pred = np.where(Y_pred >= 0.5, 1, 0)

import itertools
def plot_confusion_matrix(cm, classes,
                        normalize=False,
                        title='Confusion matrix',
                        cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    print(cm)

    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, cm[i, j],
            horizontalalignment="center",
            color="white" if cm[i, j] > thresh else "black")

    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    file_path = "/content/gdrive/My Drive/FALL 2020/ENGR 361 Scientific Research Communication/Assignments/Research Report"
    #plt.savefig(f"{file_path}/confusion_matrix.png")
    plt.savefig(f"{file_path}/confusion_matrix.svg", format='svg', dpi=120)

print('Confusion Matrix')
cm = confusion_matrix(test_generator.classes, y_pred)
cm_plot_labels = ['Normal','Pneumonia']
plot_confusion_matrix(cm=cm, classes=cm_plot_labels, title='VGG 16 Confusion Matrix')

print('\nClassification Report')
target_names = ['NORMAL', 'PNEUMONIA']
print(classification_report(test_generator.classes, y_pred, target_names=target_names))

test_loss, test_acc = model.evaluate_generator(test_generator, STEP_SIZE_TEST)
print('Accuracy on test dataset: ', round(test_acc*100, 2), '%')

model.save('pneumonia_vgg16.h5')

"""# MobileNet"""

from keras.applications import MobileNet

conv_base = MobileNet(weights= 'imagenet',
                 include_top= False,
                 input_shape=(img_width, img_height, 3))

model = models.Sequential() 
model.add(conv_base)
model.add(layers.Flatten()) 
model.add(layers.Dense(500, activation='relu')) 
model.add(layers.Dense(1, activation='sigmoid'))

model.summary()

conv_base.trainable = False

import os
from keras.preprocessing.image import ImageDataGenerator


base_dir = r'/content/gdrive/My Drive/chest_xray'
train_dir = os.path.join(base_dir, 'train')
validation_dir = os.path.join(base_dir, 'val')
test_dir = os.path.join(base_dir, 'test')

train_sample_size = 5216
train_batch_size = 32

valid_sample_size = 16
valid_batch_size = 8

test_sample_size = 624
test_batch_size = 32

from keras.preprocessing.image import ImageDataGenerator
train_datagen = ImageDataGenerator( 
                  rescale=1./255,
                  rotation_range=300, 
                  width_shift_range=0.1, 
                  height_shift_range=0.1, 
                  shear_range=0.2, 
                  zoom_range=0.2, 
                  horizontal_flip=True, 
                  fill_mode='nearest')

test_datagen = ImageDataGenerator(rescale=1./255)

train_generator = train_datagen.flow_from_directory(
        train_dir,
        target_size=(img_width, img_height),
        batch_size= train_batch_size,
        class_mode='binary')

validation_generator = test_datagen.flow_from_directory(
        validation_dir,
        target_size=(img_width, img_height),
        batch_size= valid_batch_size,
        class_mode='binary')

from keras import optimizers
model.compile(loss='binary_crossentropy', optimizer='RMSprop',
              metrics=['acc'])

STEP_SIZE_TRAIN = train_generator.n//train_generator.batch_size
STEP_SIZE_VALID = validation_generator.n//validation_generator.batch_size

history = model.fit_generator( 
      train_generator,
      steps_per_epoch=STEP_SIZE_TRAIN,
      epochs=8,
      validation_data=validation_generator,
      validation_steps=STEP_SIZE_VALID)

plot_result(history, "MobileNet")

acc = history.history['acc'] 
val_acc = history.history['val_acc'] 
train_accMobileNet = acc[-1]
val_accMobileNet   = val_acc[-1]
print(train_accMobileNet)
print(val_accMobileNet)

test_batch_size = 1
test_generator = test_datagen.flow_from_directory(
                                directory= test_dir, 
                                target_size= (img_width, img_height), 
                                batch_size= test_batch_size,
                                class_mode= 'binary', 
                                shuffle= False)

from sklearn.metrics import classification_report, confusion_matrix
import numpy as np

#Confusion Matrix and Classification Report
Y_pred = model.predict_generator(test_generator, 624)

y_pred = np.where(Y_pred >= 0.5, 1, 0)

print('Confusion Matrix')
cm = confusion_matrix(test_generator.classes, y_pred)
cm_plot_labels = ['Normal','Pneumonia']
plot_confusion_matrix(cm=cm, classes=cm_plot_labels, title='MobileNet Confusion Matrix')

print('\nClassification Report')
target_names = ['NORMAL', 'PNEUMONIA']
print(classification_report(test_generator.classes, y_pred, target_names=target_names))

model.save('pneumonia_mobilenet.h5')

import matplotlib
import matplotlib.pyplot as plt
import numpy as np


#labels = ['G1', 'G2', 'G3', 'G4', 'G5']
#men_means = [20, 34, 30, 35, 27]
#women_means = [25, 32, 34, 20, 25]

labels = ['VGG16', 'MobileNet']
train_accuracies = [94, 95]
val_accuracies =   [88, 100]


x = np.arange(len(labels))  # the label locations
width = 0.45  # the width of the bars

fig, ax = plt.subplots()
#rects1 = ax.bar(x - width/2, men_means, width, label='Men')
#rects2 = ax.bar(x + width/2, women_means, width, label='Women')

rects1 = ax.bar(x + width/2, train_accuracies, width, label='Train')
rects2 = ax.bar(x + width/2, val_accuracies, width, label='Validation')


# Add some text for labels, title and custom x-axis tick labels, etc.
ax.set_ylabel('Accuracy (%)')
ax.set_title('Accuracy comparison on training, validation, and test dataset')
ax.set_xticks(x)
ax.set_xticklabels(labels)
ax.legend()


def autolabel(rects):
    """Attach a text label above each bar in *rects*, displaying its height."""
    for rect in rects:
        height = rect.get_height()
        ax.annotate('{}'.format(height),
                    xy=(rect.get_x() + rect.get_width() / 2, height),
                    xytext=(0, 3),  # 3 points vertical offset
                    textcoords="offset points",
                    ha='center', va='bottom')


autolabel(rects1)
autolabel(rects2)


fig.tight_layout()

plt.show()

# libraries
import numpy as np
import matplotlib.pyplot as plt
 
# set width of bar
barWidth = 0.20

0.9363496899604797
0.875
 
# set height of bar
train_accuracies = [94, 95]
val_accuracies =   [88, 100]
test_accuracies =  [91, 92]
 
# Set position of bar on X axis
r1 = np.arange(len(train_accuracies))
r2 = [x + barWidth for x in r1]
r3 = [x + barWidth for x in r2]
 
# Make the plot
plt.bar(r1, train_accuracies, color='red$', width=barWidth, edgecolor='white', label='Train')
plt.bar(r2, val_accuracies, color='green', width=barWidth, edgecolor='white', label='Val')
plt.bar(r3, test_accuracies, color='blue', width=barWidth, edgecolor='white', label='Test')
 
# Add xticks on the middle of the group bars
plt.xlabel('Convents', fontweight='bold')
plt.xticks([r + barWidth for r in range(len(train_accuracies))], ['VGG16', 'MobileNet'])
plt.title('Accuracy comparison on training, validation, and test dataset')
plt.ylabel('Accuracy (%)')

plt.legend(bbox_to_anchor=(1.25, 1), loc='upper right', ncol=1)

y = [94,95,88,100,91,92]
for i, v in enumerate(y):
    plt.text(v + 3, i + .25, str(v), color='blue', fontweight='bold')

# Create legend & Show graphic
plt.show()